from types import TracebackType
from typing import Optional, TypeVar, Generic, Any, Callable, Dict, Type
from typing_extensions import ParamSpec, Self, Coroutine, TypedDict, Literal

T = TypeVar("T")
B = TypeVar("B")
P = ParamSpec('P')

class Event(TypedDict, Generic[B]):
    type: Literal["ADDED","BOOKMARK","MODIFIED","DELETED"]
    raw_object: Dict[str,Any]
    object: B


class Watch():
    def __init__(self, return_type: Optional[str]=None) -> None: ...


    def stop(self) -> None: ...


    def __aiter__(self) -> Self: ...

    async def __anext__(self) -> Any: ...
    async def next(self) -> Any: ...

    def stream(self, func: Callable[P, Coroutine[Any,Any, B]], *args: P.args, **kwargs: P.kwargs) -> Watch_T[Event[B]]: ...

    async def close(self) -> None: ...

    async def __aenter__(self) -> Self: ...

    async def __aexit__(self, exc_type:  Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback:  Optional[TracebackType]) -> None: ...

# have a special typed version of Watch which is returned by the stream function. this type never exists in reality hence the _T
class Watch_T(Generic[T], Watch):
    def __init__(self, return_type: Optional[str]=None) -> None: ...


    def stop(self) -> None: ...


    def __aiter__(self) -> Self: ...

    async def __anext__(self) -> T: ...
    async def next(self) -> T: ...

    def stream(self, func: Callable[P, Coroutine[Any,Any, B]], *args: P.args, **kwargs: P.kwargs) -> Watch_T[Event[B]]: ...

    async def close(self) -> None: ...

    async def __aenter__(self) -> Self: ...

    async def __aexit__(self, exc_type:  Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback:  Optional[TracebackType]) -> None: ...


